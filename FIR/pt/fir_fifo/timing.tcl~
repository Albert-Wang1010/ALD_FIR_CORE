## Timing constraints for FIR_FIFO (Asynchronous FIFO/Synchronizer)
## Columbia University - Advanced Logic Design Lab #8
## Dual-clock domain crossing design with CDC synchronizers
##
## Design: fir_fifo
## Technology: IBM 13nm RF LVT
## Target: Post-synthesis timing and power analysis with PrimeTime
##
## The unit for time is ns as defined in the IBM delay-power library
## The unit for wireload is pF as defined in the IBM delay-power library
###################################################################### 

###################################################################### 
# Clock Domain 1: clk1 (10 kHz - Input Sampling Clock)
# Used for ADC sample input at 10 kS/s rate
###################################################################### 
set clk1_period 100000.0
set clk1_uncertainty 1.0
set clk1_transition 1.0

if {[sizeof_collection [get_ports clk1]] > 0} {
  create_clock -name clk1 -period $clk1_period [get_ports clk1]
  set_clock_uncertainty $clk1_uncertainty [get_clocks clk1]
  set_clock_transition $clk1_transition [get_clocks clk1]
}

###################################################################### 
# Clock Domain 2: clk2 (100 MHz - Core Processing Clock)
# Used for FIR filter core processing
###################################################################### 
set clk2_period 10.0
set clk2_uncertainty 0.25
set clk2_transition 0.15

if {[sizeof_collection [get_ports clk2]] > 0} {
  create_clock -name clk2 -period $clk2_period [get_ports clk2]
  set_clock_uncertainty $clk2_uncertainty [get_clocks clk2]
  set_clock_transition $clk2_transition [get_clocks clk2]
}

###################################################################### 
# Clock Groups - Mark clocks as asynchronous to each other
# CRITICAL: This prevents timing analysis across clock domains
# Without this, synthesis will fail trying to meet impossible timing
###################################################################### 
set_clock_groups -asynchronous -group {clk1} -group {clk2}

###################################################################### 
# Input Constraints - clk1 domain (Write Interface)
###################################################################### 
set clk1_input_delay 10000.0

if {[sizeof_collection [get_ports wen]] > 0} {
  set_driving_cell -lib_cell INVX1TS [get_ports wen]
  set_input_delay $clk1_input_delay [get_ports wen] -clock clk1
}

if {[sizeof_collection [get_ports din*]] > 0} {
  set_driving_cell -lib_cell INVX1TS [get_ports din*]
  set_input_delay $clk1_input_delay [get_ports din*] -clock clk1
}

###################################################################### 
# Input Constraints - clk2 domain (Read Interface)
###################################################################### 
set clk2_input_delay 1.0

if {[sizeof_collection [get_ports ren]] > 0} {
  set_driving_cell -lib_cell INVX1TS [get_ports ren]
  set_input_delay $clk2_input_delay [get_ports ren] -clock clk2
}

###################################################################### 
# Output Constraints - clk1 domain
###################################################################### 
set clk1_output_delay 5000.0

if {[sizeof_collection [get_ports full]] > 0} {
  set_output_delay $clk1_output_delay [get_ports full] -clock clk1
  set_load 0.1 [get_ports full]
}

###################################################################### 
# Output Constraints - clk2 domain
###################################################################### 
set clk2_output_delay 0.5

if {[sizeof_collection [get_ports empty]] > 0} {
  set_output_delay $clk2_output_delay [get_ports empty] -clock clk2
  set_load 0.01 [get_ports empty]
}

if {[sizeof_collection [get_ports dout*]] > 0} {
  set_output_delay $clk2_output_delay [get_ports dout*] -clock clk2
  set_load 0.01 [get_ports dout*]
}

###################################################################### 
# Asynchronous Reset Constraints
# These are truly asynchronous and should not be timed
###################################################################### 

# rstn1 (write domain reset)
if {[sizeof_collection [get_ports rstn1]] > 0} {
  set_false_path -from [get_ports rstn1]
  set_max_transition 2.0 [get_ports rstn1]
}

# rstn2 (read domain reset)
if {[sizeof_collection [get_ports rstn2]] > 0} {
  set_false_path -from [get_ports rstn2]
  set_max_transition 2.0 [get_ports rstn2]
}

###################################################################### 
# CDC False Paths - CRITICAL for Clock Domain Crossing
# These prevent timing violations on CDC synchronizers
# Gray code pointer crossings use 2-FF synchronizers
###################################################################### 

# False path from write pointer Gray code to read domain synchronizer
# Path: wptr_gray_reg -> wptr_gray_sync1_reg (crosses clk1 to clk2)
# This is intentionally asynchronous and protected by 2-FF synchronizer
if {[sizeof_collection [get_pins -hierarchical *wptr_gray_reg*/Q]] > 0} {
  if {[sizeof_collection [get_pins -hierarchical *wptr_gray_sync1_reg*/D]] > 0} {
    set_false_path -from [get_pins -hierarchical *wptr_gray_reg*/Q] \
                   -to [get_pins -hierarchical *wptr_gray_sync1_reg*/D]
  }
}

# False path from read pointer Gray code to write domain synchronizer
# Path: rptr_gray_reg -> rptr_gray_sync1_reg (crosses clk2 to clk1)
# This is intentionally asynchronous and protected by 2-FF synchronizer
if {[sizeof_collection [get_pins -hierarchical *rptr_gray_reg*/Q]] > 0} {
  if {[sizeof_collection [get_pins -hierarchical *rptr_gray_sync1_reg*/D]] > 0} {
    set_false_path -from [get_pins -hierarchical *rptr_gray_reg*/Q] \
                   -to [get_pins -hierarchical *rptr_gray_sync1_reg*/D]
  }
}

###################################################################### 
# Multi-cycle Paths
# wen signal is stable for multiple clk1 cycles during FIR operation
###################################################################### 
if {[sizeof_collection [get_ports wen]] > 0} {
  set_multicycle_path 2 -setup -from [get_ports wen]
  set_multicycle_path 1 -hold -from [get_ports wen]
}

###################################################################### 
# Design Rule Constraints
# Based on IBM 13nm RF LVT technology
###################################################################### 
set_max_fanout 16 [current_design]
set_max_transition 1.0 [current_design]
set_max_capacitance 0.5 [current_design]

###################################################################### 
# Max Delay Constraint (for analysis)
# Set realistic max delay for clk1 paths (90% of clock period)
# This keeps timing reports reasonable for the very slow 10kHz clock
###################################################################### 
set_max_delay 90000.0 -from [get_clocks clk1] -to [get_clocks clk1]

###################################################################### 
# CDC Synchronizer Notes
# The 2-FF synchronizers in the design are critical for metastability
# protection. These were preserved during synthesis with set_size_only.
# In PrimeTime, we just verify the timing - no synthesis commands needed.
###################################################################### 

###################################################################### 
# Operating Conditions
# Using typical corner for post-synthesis analysis
###################################################################### 
set_operating_conditions tt_1p2v_25c -library scx3_cmos8rf_lpvt_tt_1p2v_25c

###################################################################### 
# Wire Load Model
# Using conservative wire load for post-synthesis
###################################################################### 
set_wire_load_mode top
